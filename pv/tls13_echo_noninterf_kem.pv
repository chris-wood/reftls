(********************************************************)
(* ECHO *)
(********************************************************)
(* ../../proverif2.00/proverif tls13_echo_noninterf.pv | grep RESULT *)

(* Library Functions and Types *)

const zero: bitstring.

(********************************************************)
(* Authenticated encryption *)
(********************************************************)

type ae_alg.
const StrongAE: ae_alg [data].
const WeakAE: ae_alg [data].

type ae_key.
fun b2k(bitstring): ae_key [data].

fun ae_enc_ideal(ae_key,bitstring):bitstring.
fun ae_dec_ideal(ae_key,bitstring):bitstring
reduc forall k:ae_key, b:bitstring;
      ae_dec_ideal(k,ae_enc_ideal(k,b)) = b.

fun ae_enc(ae_alg,ae_key,bitstring): bitstring
reduc forall a:ae_alg, k:ae_key, p:bitstring;
      ae_enc(WeakAE, k, p) = p
otherwise forall a:ae_alg, k:ae_key, p:bitstring;
      ae_enc(StrongAE, k, p) = ae_enc_ideal(k,p).

fun ae_dec(ae_alg,ae_key,bitstring): bitstring
reduc forall a:ae_alg, k:ae_key, p:bitstring;
      ae_dec(WeakAE, k, p) = p
otherwise forall a:ae_alg, k:ae_key, p:bitstring;
      ae_dec(StrongAE, k, ae_enc_ideal(k,p)) = p.

(********************************************************)
(* Diffie-Hellman, modeled as a KEM *)
(********************************************************)

type group.
const WeakDH: group [data].
const StrongDH: group [data].

type element.
const guessable: element.
fun e2b(element): bitstring [data].

(* Key Generation *)
fun dh_pub(group,bitstring): element.

fun discrete_log(element): bitstring
reduc forall x:bitstring;
      discrete_log(dh_pub(WeakDH,x)) = x.

letfun dh_keygen(g:group) =
  new x:bitstring;
  let gx = dh_pub(g,x) in
  (x,gx).

(* Encap/Decap Functionality *)
fun dh_encap_fun(group,element,element):element.
fun dh_decap_fun(group,element,bitstring): element
reduc forall g:group, x:bitstring, gxy:element;
      dh_decap_fun(g,dh_encap_fun(g,dh_pub(g,x),gxy),x) = gxy.

(* Generate then Encap *)
letfun dh_encap(g:group,gx:element) =
  new gxy:element;
  (gxy, dh_encap_fun(g,gx,gxy)).

(* Decap: never fails *)
letfun dh_decap(g:group,gy:element,x:bitstring) =
  let gxy = dh_decap_fun(g,gy,x) in
    gxy
  else (
    new gxy:element;
    gxy).

(********************************************************)
(* Hash Functions, including those with collisions. See SLOTH *)
(********************************************************)

type hash_alg.
const StrongHash: hash_alg [data].
const WeakHash: hash_alg [data].

const collision:bitstring [data].
fun hash_ideal(bitstring):bitstring.

fun hash(hash_alg,bitstring): bitstring
reduc forall x:bitstring;
      hash(WeakHash,x) = collision
otherwise forall x:bitstring;
      hash(StrongHash,x) = hash_ideal(x).

(********************************************************)
(* HMAC *)
(********************************************************)

type mac_key.
fun b2mk(bitstring):mac_key [data,typeConverter].

const forgery:bitstring [data].
fun hmac_ideal(mac_key,bitstring): bitstring.

fun hmac(hash_alg,mac_key,bitstring):bitstring
reduc forall k:mac_key, x:bitstring;
      hmac(WeakHash,k, x) = forgery
otherwise forall x:bitstring, k:mac_key;
      hmac(StrongHash,k, x) = hmac_ideal(k,x).

(********************************************************)
(* HKDF *)
(********************************************************)

letfun prf(k:bitstring,x:bitstring) =
       hmac(StrongHash,b2mk(k),x).

letfun hkdf_extract(s:bitstring,k:bitstring) =
       prf(s,k).

type label.
const nonce_label, hrr_key_label, echo_key, echo_iv: label.

letfun hkdf_expand_label(k:bitstring,l:label,h:bitstring) =
       prf(k,(l,h)).

(********************************************************)
(* HPKE *)
(********************************************************)

letfun hpke_encap_export(pkR:element, l1:label, l2:label) =
  let (geR:element,ge:element) = dh_encap(StrongDH,pkR) in
  let l1_export = hkdf_expand_label(e2b(geR),l1,zero) in
  let l2_export = hkdf_expand_label(e2b(geR),l2,zero) in
  let key = b2k(hkdf_extract(zero,e2b(geR))) in
  (ge,key,l1_export,l2_export).

letfun hpke_encap_psk_export(pkR:element, psk:bitstring, l:label) =
  let (geR:element,ge:element) = dh_encap(StrongDH,pkR) in
  let export = hkdf_expand_label(e2b(geR),l,psk) in
  let key = b2k(hkdf_extract(psk,e2b(geR))) in
  (ge,key,export).

letfun hpke_decap_export(ge:element, skR:bitstring, l1:label, l2:label) =
  let geR = dh_decap(StrongDH,ge,skR) in
  let l1_export = hkdf_expand_label(e2b(geR),l1,zero) in
  let l2_export = hkdf_expand_label(e2b(geR),l2,zero) in
  let key = b2k(hkdf_extract(zero,e2b(geR))) in
  (key,l1_export,l2_export).

letfun hpke_decap_psk_export(ge:element, skR:bitstring, psk:bitstring, l:label) =
  let geR = dh_decap(StrongDH,ge,skR) in
  let export = hkdf_expand_label(e2b(geR),l,psk) in
  let key = b2k(hkdf_extract(psk,e2b(geR))) in
  (key,export).

(********************************************************)
(* Signatures and Certificates *)
(********************************************************)
type sig_key.
type verif_key.
fun vk(sig_key):verif_key.
fun vk2b(verif_key):bitstring [data].

fun sign(sig_key,bitstring): bitstring.
fun verify(verif_key,bitstring,bitstring): bool
reduc forall sk:sig_key, p:bitstring, sg:bitstring;
      verify(vk(sk), p, sign(sk,p)) = true.

type domain.
fun privkey(domain):sig_key [private].
fun cert(domain,verif_key): bitstring [data].

const A: domain.
const B: domain.
const F: domain.


(* Parametric "sni-independent" processing of sni at the server *)
letfun get_cert(sni:domain) =
       cert(sni,vk(privkey(sni))).
(* Using the following instead would break noninterf of sni
   because of the comparisons:
       if sni = A then cert(A)
       else if sni = B then cert(B)
       else cert(F).
*)

letfun validate_cert(d:domain,c:bitstring) =
       if c = cert(d,vk(privkey(d))) then
       	  vk(privkey(d)).


(********************************************************)
(* TLS helper types *)
(********************************************************)
type client_message_type.
const CH1, CH2: client_message_type.
type server_message_type.
const SH, HRR: server_message_type.

(********************************************************)
(* ECHO events *)
(********************************************************)
event ECHOClientDone(domain,element,bitstring,bitstring).
event ECHOClientHRRDone(domain,element,bitstring,bitstring).
event ECHOServerDone(domain,element,bitstring,bitstring).
event ECHOServerHRRDone(domain,element,bitstring,bitstring).
event ECHOClientFallbackDone(domain,element,bitstring).
event ECHOClientHRRFallbackDone(domain,element,bitstring).
event ECHOServerFallbackDone(domain,element,bitstring).
event ECHOClientAcceptWithMismatch(bitstring,bitstring).
event ECHOClientHRRAcceptWithMismatch(bitstring,bitstring).
event ServerFallbackReachable(bitstring).
event ServerSuccessReachable(bitstring).
event ClientOuterReachable().
event ClientInnerUnreachable().
event ClientHRRInnerReachable().
event ClientInnerReachable().
event ClientInnerMismatchReachable().
event ClientHRRInnerMismatchReachable().
event ClientOuterUnreachable().
event ClientHRROuterUnreachable().
event ClientHRROuterReachable().
event ServerRetryReachable().
event ClientHRRReachable().
event ClientSecondHRRReachable().
event Compromise(domain).

(* TODO: introduce public parameters and private parameters *)
(*
letfun allow_hrr_attack() = true.
letfun enforce_hrr_check() = true.
*)
free io:channel.

let ClientECHO(frontend:domain,pkR:element,origin:domain) =
  (* Prepare ECHO Keys *)
  let (ge:element, hpke_key: ae_key, inner_nonce: bitstring, hrr_key: bitstring) =
      hpke_encap_export(pkR,nonce_label,hrr_key_label) in

  (* ClientHelloInner *)
  let g = StrongDH in
  let (x_inner:bitstring,gx_inner:element) = dh_keygen(g) in
  let ch_inner = (gx_inner, origin, inner_nonce) in

  (* ECHO *)
  let echo = ae_enc(StrongAE,hpke_key,ch_inner) in

  (* ClientHelloOuter *)
  let (x_outer:bitstring,gx_outer:element) = dh_keygen(g) in
  let ch_outer = (gx_outer, frontend, pkR, ge, echo) in

  (* Send ClientHelloOuter *)
  out (io,(CH1,ch_outer));

  (* Read a SH (or HRR) from the server *)
  in (io, (msg_type:server_message_type,sh:bitstring));

  (* Handle the SH case first *)
  if msg_type = SH then (
    let (gy:element,ecert:bitstring,esig:bitstring) = sh in
    let gxy_inner = dh_decap(g,gy,x_inner) in
    let k_inner = b2k(hkdf_extract((CH1,ch_inner,SH),e2b(gxy_inner))) in
    let cert_origin = ae_dec(StrongAE,k_inner,ecert) in (
      let sig_origin = ae_dec(StrongAE,k_inner,esig) in
      let vk_origin = validate_cert(origin,cert_origin) in
      if verify(vk_origin,(ch_inner,gy,cert_origin),sig_origin) then (
        (* ECHO accept with cert match *)
        event ClientInnerReachable;
        event ECHOClientDone(origin,pkR,ch_inner,inner_nonce))
      else (
        (* ECHO accept with cert mismatch -- configuration error *)
        event ClientInnerMismatchReachable;
        event ECHOClientAcceptWithMismatch(ch_inner,inner_nonce)))
    else (
      (* Otherwise, assume the outer CH was used *)
      let gxy_outer = dh_decap(g,gy,x_outer) in
      let k_outer = b2k(hkdf_extract((CH1,ch_outer,SH),e2b(gxy_outer))) in
      let cert_frontend = ae_dec(StrongAE,k_outer,ecert) in
      let sig_frontend = ae_dec(StrongAE,k_outer,esig) in
      let vk_frontend = validate_cert(frontend,cert_frontend) in
      if verify(vk_frontend,(ch_outer,gy,cert_frontend),sig_frontend) then (
        (* ECHO reject *)
        event ClientOuterReachable;
        event ECHOClientFallbackDone(frontend,pkR,ch_outer))
      else (
        event ClientOuterUnreachable)))
  else (
    (* Handle a HRR *)
    event ClientHRRReachable;

    (* TODO(caw): can we factor out this functionality into a helper function? It generates fresh values for each parameter. *)

    (* Prepare fresh ECHO Keys *)
    let (ge_2:element, hpke_key_2: ae_key, inner_nonce_2: bitstring) =
        hpke_encap_psk_export(pkR,hrr_key,nonce_label) in

    (* ClientHelloInner for CH2 *)
    let (x_inner_2:bitstring,gx_inner_2:element) = dh_keygen(g) in
    let ch_inner_2 = (gx_inner_2, origin, inner_nonce_2) in

    (* ECHO *)
    let echo_2 = ae_enc(StrongAE,hpke_key_2,ch_inner_2) in

    (* ClientHelloOuter *)
    let (x_outer_2:bitstring,gx_outer_2:element) = dh_keygen(g) in
    let ch_outer_2 = (gx_outer_2, frontend, pkR, ge_2, echo_2) in

    (* Send ClientHelloOuter *)
    out (io,(CH2,ch_outer_2));

    (* Read a SH from the server *)
    in (io, (msg_type_2:server_message_type,sh_2:bitstring));

    if msg_type_2 = SH then (
      let (gy:element,ecert:bitstring,esig:bitstring) = sh in
      let gxy_inner = dh_decap(g,gy,x_inner_2) in

      (* TODO(caw): is this the right transcript for HRR key derivation? *)
      let k_inner = b2k(hkdf_extract((CH1,ch_inner,HRR,CH2,ch_inner_2,SH),e2b(gxy_inner))) in
      let cert_origin = ae_dec(StrongAE,k_inner,ecert) in (
        let sig_origin = ae_dec(StrongAE,k_inner,esig) in
        let vk_origin = validate_cert(origin,cert_origin) in
        if verify(vk_origin,(ch_inner_2,gy,cert_origin),sig_origin) then (
          (* ECHO accept with cert match *)
          event ClientHRRInnerReachable;
          event ECHOClientHRRDone(origin,pkR,ch_inner_2,inner_nonce_2))
        else (
          (* ECHO accept with cert mismatch -- configuration error *)
          event ClientHRRInnerMismatchReachable;
          event ECHOClientHRRAcceptWithMismatch(ch_inner_2,inner_nonce_2)))
      else (
        (* Otherwise, assume the outer CH was used *)
        let gxy_outer = dh_decap(g,gy,x_outer_2) in
        let k_outer = b2k(hkdf_extract((CH1,ch_outer,HRR,CH2,ch_outer_2,SH),e2b(gxy_outer))) in
        let cert_frontend = ae_dec(StrongAE,k_outer,ecert) in
        let sig_frontend = ae_dec(StrongAE,k_outer,esig) in
        let vk_frontend = validate_cert(frontend,cert_frontend) in
        if verify(vk_frontend,(ch_outer,gy,cert_frontend),sig_frontend) then (
          (* ECHO reject *)
          event ClientHRROuterReachable;
          event ECHOClientHRRFallbackDone(frontend,pkR,ch_outer_2))
        else (
          event ClientHRROuterUnreachable)))
    else (
      (* Reaching here means we got two HRRs, which is a protocol violation. Fail silently. *)
      event ClientSecondHRRReachable)).

type flag.
const flag_true, flag_false: flag.

let ServerECHO(frontend:domain,skR:bitstring,should_retry:flag) =
  in (io,(=CH1,ch_outer:bitstring));
  let (gx_outer:element,=frontend,target_pk:element,ge:element,echo:bitstring) = ch_outer in
  let g = StrongDH in
  let pkR = dh_pub(g,skR) in

  (* Check to see if we can process the ECHO extension (do we have the matching key?). *)
  (* If not, fallback. Otherwise, proceed and do HRR check. *)
  if target_pk = pkR then (
    let (hpke_key:ae_key, inner_nonce:bitstring, hrr_binder_key:bitstring) =
      hpke_decap_export(ge,skR,nonce_label,hrr_key_label) in

      if should_retry = flag_false then (
        let ch_inner = ae_dec(StrongAE,hpke_key,echo) in
        let (gx_inner:element,origin:domain,=inner_nonce) = ch_inner in

        event ServerSuccessReachable(ch_inner);

        let (gxy_inner:element,gy:element) = dh_encap(g,gx_inner) in
        let cert_origin = get_cert(origin) in
        let sk_origin = privkey(origin) in
        let sig_origin = sign(sk_origin, (ch_inner, gy, cert_origin)) in

        let k_inner = b2k(hkdf_extract((CH1,ch_inner,SH),e2b(gxy_inner))) in
        let ecert = ae_enc(StrongAE,k_inner,cert_origin) in
        let esig = ae_enc(StrongAE,k_inner,sig_origin) in
        let sh = (gy,ecert,esig) in

        event ECHOServerDone(origin,pkR,ch_inner,inner_nonce);
        out (io,(SH, sh)))
      else (
        (* Send HRR *)
        event ServerRetryReachable;
        out (io,(HRR, zero));

        in (io,(=CH2,ch_outer_2:bitstring));
        let (gx_outer_2:element,=frontend,target_pk_2:element,ge_2:element,echo_2:bitstring) = ch_outer_2 in
        let g = StrongDH in
        let pkR = dh_pub(g,skR) in
        if target_pk_2 = pkR then (
          let (hpke_key_2:ae_key, inner_nonce_2:bitstring) =
            hpke_decap_psk_export(ge_2,skR,hrr_binder_key,nonce_label) in
          let ch_inner = ae_dec(StrongAE,hpke_key_2,echo_2) in

          let (gx_inner:element,origin:domain,=inner_nonce) = ch_inner in

          event ServerSuccessReachable(ch_inner);

          let (gxy_inner:element,gy:element) = dh_encap(g,gx_inner) in
          let cert_origin = get_cert(origin) in
          let sk_origin = privkey(origin) in
          let sig_origin = sign(sk_origin, (ch_inner, gy, cert_origin)) in

          let k_inner = b2k(hkdf_extract((CH1,ch_inner,HRR,CH2,ch_inner,SH),e2b(gxy_inner))) in
          let ecert = ae_enc(StrongAE,k_inner,cert_origin) in
          let esig = ae_enc(StrongAE,k_inner,sig_origin) in
          let sh = (gy,ecert,esig) in

          event ECHOServerHRRDone(origin,pkR,ch_inner,inner_nonce);
          out (io,(SH, sh)))
        else (
          (* Fallback to public name and CHOuter2 *)
          let (gxy_outer:element,gy:element) = dh_encap(g,gx_outer_2) in
          let cert_frontend = get_cert(frontend) in
          let sk_frontend = privkey(frontend) in
          let sig_frontend = sign(sk_frontend, (ch_outer, gy, cert_frontend)) in

          let k_outer = b2k(hkdf_extract((CH1,ch_outer,SH),e2b(gxy_outer))) in
          let ecert = ae_enc(StrongAE,k_outer,cert_frontend) in
          let esig = ae_enc(StrongAE,k_outer,sig_frontend) in
          let sh = (gy,ecert,esig) in
          event ServerFallbackReachable(ch_outer);
          event ECHOServerFallbackDone(frontend,pkR,ch_outer);
          out (io,(SH, sh)))))
  else (
    (* Fallback to public name and CHOuter *)
    let (gxy_outer:element,gy:element) = dh_encap(g,gx_outer) in
    let cert_frontend = get_cert(frontend) in
    let sk_frontend = privkey(frontend) in
    let sig_frontend = sign(sk_frontend, (ch_outer, gy, cert_frontend)) in

    let k_outer = b2k(hkdf_extract((CH1,ch_outer,SH),e2b(gxy_outer))) in
    let ecert = ae_enc(StrongAE,k_outer,cert_frontend) in
    let esig = ae_enc(StrongAE,k_outer,sig_frontend) in
    let sh = (gy,ecert,esig) in
    event ServerFallbackReachable(ch_outer);
    event ECHOServerFallbackDone(frontend,pkR,ch_outer);
    out (io,(SH, sh))).

(********************************************************)
(* Queries *)
(********************************************************)

(* Assert that the protocol completes with sane values *)
query d:domain, p:element, n:bitstring, ch_inner:bitstring, ch_outer:bitstring;
  (* Basic trace reachable events *)
  event(ClientOuterReachable);
  event(ClientInnerReachable);
  event(ClientHRROuterReachable);
  event(ClientHRRInnerReachable);
  event(ServerRetryReachable);
  event(ClientOuterUnreachable);
  event(ServerFallbackReachable(ch_outer));
  event(ServerSuccessReachable(ch_inner));

  (* Basic trace unreachable events *)
  event(ClientInnerMismatchReachable);
  event(ECHOClientAcceptWithMismatch(ch_inner,n));

  (* Protocol completion reachable events *)
  event(ECHOClientDone(d,p,ch_inner,n)) ==> event(ECHOServerDone(d,p,ch_inner,n));
  event(ECHOClientHRRDone(d,p,ch_inner,n)) ==> event(ECHOServerHRRDone(d,p,ch_inner,n));
  event(ECHOClientDone(chosen_sni,p,ch_inner,n)) ==> event(ECHOServerDone(chosen_sni,p,ch_inner,n));
  event(ECHOClientHRRDone(chosen_sni,p,ch_inner,n)) ==> event(ECHOServerHRRDone(chosen_sni,p,ch_inner,n));
  event(ECHOClientFallbackDone(F,p,ch_outer)) ==> event(ECHOServerFallbackDone(F,p,ch_outer));

  event(ECHOClientDone(F,p,ch_inner,n));
  event(ECHOClientDone(A,p,ch_inner,n));
  event(ECHOClientDone(B,p,ch_inner,n));
  event(ECHOClientDone(chosen_sni,p,ch_inner,n));

  event(ECHOClientHRRDone(F,p,ch_inner,n));
  event(ECHOClientHRRDone(A,p,ch_inner,n));
  event(ECHOClientHRRDone(B,p,ch_inner,n));
  event(ECHOClientHRRDone(chosen_sni,p,ch_inner,n));

  event(ECHOServerDone(F,p,ch_inner,n));
  event(ECHOServerDone(A,p,ch_inner,n));
  event(ECHOServerDone(B,p,ch_inner,n));
  event(ECHOServerDone(chosen_sni,p,ch_inner,n));

  event(ECHOServerHRRDone(F,p,ch_inner,n));
  event(ECHOServerHRRDone(A,p,ch_inner,n));
  event(ECHOServerHRRDone(B,p,ch_inner,n));
  event(ECHOServerHRRDone(chosen_sni,p,ch_inner,n));

  event(ECHOServerFallbackDone(F,p,ch_outer));
  event(ECHOClientFallbackDone(F,p,ch_outer)).

(* Main secrecy query *)
free chosen_sni:domain [private].
noninterf chosen_sni among (A,B,F).

process
  let g = StrongDH in
  let (skF:bitstring,pkF:element) = dh_keygen(g) in
  let (skA:bitstring,pkA:element) = dh_keygen(g) in

    !ClientECHO(F,pkF,A)
  | !ClientECHO(F,pkF,B)
  | !ClientECHO(F,pkF,F)
  | !ClientECHO(F,pkF,chosen_sni) 
  | !ServerECHO(F,skF,flag_false) (* server with correct key, which doesn't HRR *)
  | !ServerECHO(F,skF,flag_true) (* server with correct key, which does HRR *)

  (* another compromised frontend server *)
  | !ClientECHO(A,pkA,B)
  | !ServerECHO(A,skA,flag_false)

  | (event Compromise(A); out(io,privkey(A)))
  | (event Compromise(B); out(io,privkey(B)))
  | (event Compromise(F); out(io,privkey(F)))
  | (event Compromise(A); out(io,(skA,privkey(A))))
  (*  | (event Compromise(F); out(io,(skF,privkey(F)))) *) 


