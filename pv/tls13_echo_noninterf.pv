(********************************************************)
(* ECHO *)
(********************************************************)
(* ../../proverif2.00/proverif tls13_echo_noninterf.pv | grep RESULT *)

(* Library Functions and Types *)

const zero: bitstring.

(********************************************************)
(* Symmetric encryption *)
(********************************************************)
type symkey.
fun b2k(bitstring): symkey [data].
fun sym_enc(symkey,bitstring):bitstring.
fun sym_dec(symkey,bitstring):bitstring
reduc forall k:symkey, b:bitstring;
      sym_dec(k,sym_enc(k,b)) = b.

(********************************************************)
(* Diffie-Hellman *)
(********************************************************)

type group.
const StrongDH: group [data].

type element.
fun e2b(element): bitstring [data].
const G: element [data].

fun dh_ideal(element,bitstring):element.
equation forall x:bitstring, y:bitstring;
   dh_ideal(dh_ideal(G,x),y) =
   dh_ideal(dh_ideal(G,y),x).

fun dh_exp(group,element,bitstring):element
reduc forall g:group, e:element, x:bitstring;
      dh_exp(StrongDH,e,x) = dh_ideal(e,x).

letfun dh_keygen(g:group) =
  new x:bitstring;
  let gx = dh_exp(g,G,x) in
  (x,gx).

(********************************************************)
(* Hash Functions, including those with collisions. See SLOTH *)
(********************************************************)

type hash_alg.
const StrongHash: hash_alg [data].
const WeakHash: hash_alg [data].

const collision:bitstring [data].
fun hash_ideal(bitstring):bitstring.

fun hash(hash_alg,bitstring): bitstring
reduc forall x:bitstring;
      hash(WeakHash,x) = collision
otherwise forall x:bitstring;
      hash(StrongHash,x) = hash_ideal(x).

(********************************************************)
(* HMAC and HKDF *)
(********************************************************)

type mac_key.
fun b2mk(bitstring):mac_key [data,typeConverter].

fun hmac_ideal(mac_key,bitstring): bitstring.

fun hmac(hash_alg,mac_key,bitstring):bitstring
reduc forall k:mac_key, x:bitstring;
      hmac(WeakHash,k, x) = collision
otherwise forall x:bitstring, k:mac_key;
      hmac(StrongHash,k, x) = hmac_ideal(k,x).

letfun prf(k:bitstring,x:bitstring) =
       hmac(StrongHash,b2mk(k),x).

letfun hkdf_extract(s:bitstring,k:bitstring) =
       prf(s,k).

type label.
const nonce_label, echo_key, echo_iv: label.

letfun hkdf_expand_label(k:bitstring,l:label,h:bitstring) =
       prf(k,(l,h)).

letfun hpke_export(e:element, l:label) =
  hkdf_expand_label(e2b(e),l,zero).

(********************************************************)
(* Helper types *)
(********************************************************)
type domain.
fun cert(domain): bitstring [data].

const A: domain.
const B: domain.
const F: domain.

(********************************************************)
(* TLS helper types *)
(********************************************************)
type client_message_type.
const CH1, CH2: client_message_type.
type server_message_type.
const SH: server_message_type.

(********************************************************)
(* ECHO events *)
(********************************************************)
event ECHOClientDone(domain,element,bitstring,bitstring).
event ECHOServerDone(domain,element,bitstring,bitstring).
event ECHOClientFallbackDone(domain,element,bitstring).
event ECHOServerFallbackDone(domain,element,bitstring).
event ECHOClientAcceptWithMismatch(bitstring,bitstring).
event ServerFallbackReachable(bitstring).
event ServerSuccessReachable(bitstring).
event ClientOuterReachable().
event ClientInnerUnreachable().
event ClientInnerReachable().
event ClientInnerMismatchReachable().
event ClientOuterUnreachable().
event ServerRetryReachable().

(* TODO: introduce public parameters and private parameters *)

free io:channel.

(* Parametric "sni-independent" processing of sni at the server *)
letfun get_cert(sni:domain) = cert(sni).
(* Using the following instead would break noninterf of sni
   because of the comparisons:
       if sni = A then cert(A)
       else if sni = B then cert(B)
       else cert(F).
*)

letfun validate_cert(d:domain,c:bitstring) = c = cert(d).

let ClientECHO(frontend:domain,pkR:element,origin:domain) =
  (* ClientHelloInner *)
  let g = StrongDH in
  let (x_inner:bitstring,gx_inner:element) = dh_keygen(g) in

  let (e:bitstring,ge:element) = dh_keygen(g) in
  let geR = dh_exp(g,pkR,e) in
  let hpke_nonce = hpke_export(geR,nonce_label) in
  let ch_inner = (gx_inner, origin, hpke_nonce) in

  (* ECHO *)
  let echo_zz = b2k(hkdf_extract(zero,e2b(geR))) in
  let echo = sym_enc(echo_zz,ch_inner) in

  (* ClientHelloOuter *)
  let (x_outer:bitstring,gx_outer:element) = dh_keygen(g) in
  let ch_outer = (gx_outer, frontend, pkR, ge, echo) in

  (* Read a SH (or HRR) from the server *)
  out (io,(CH1,ch_outer));
  in (io, (msg_type:server_message_type,sh:bitstring));

  if msg_type = SH then (
    (* Handle the SH case first *)
    let (gy:element,ecert:bitstring) = sh in
      let gxy_inner = dh_exp(g,gy,x_inner) in
      let k_inner = b2k(hkdf_extract((CH1,SH,ch_inner),e2b(gxy_inner))) in

      let cert_origin = sym_dec(k_inner,ecert) in (
        event ClientInnerReachable;
        if validate_cert(origin,cert_origin) then
          (* ECHO accept with cert match *)
          event ECHOClientDone(origin,pkR,ch_inner,hpke_nonce)
        else (
          (* ECHO accept with cert mismatch -- configuration error *)
          event ClientInnerMismatchReachable;
          event ECHOClientAcceptWithMismatch(ch_inner,hpke_nonce)))
      else
        (* Otherwise, assume the outer CH was used *)
        let gxy_outer = dh_exp(g,gy,x_outer) in
        let k_outer = b2k(hkdf_extract((CH1,SH,ch_outer),e2b(gxy_outer))) in
        let cert_frontend = sym_dec(k_outer,ecert) in

        if validate_cert(frontend,cert_frontend) then (
          (* ECHO reject *)
          event ClientOuterReachable;
          event ECHOClientFallbackDone(frontend,pkR,ch_outer))
        else (
          event ClientOuterUnreachable)).

type flag.
const flag_true, flag_false: flag.

let ServerECHO(frontend:domain,skR:bitstring,should_retry:flag) =
  in (io,(=CH1,ch_outer:bitstring));
  let (gx_outer:element,=frontend,target_pk:element,ge:element,echo:bitstring) = ch_outer in

  if should_retry = flag_false then (
    let g = StrongDH in
    let pkR = dh_exp(g,G,skR) in
    if target_pk = pkR then (
     let geR = dh_exp(g,ge,skR) in
     let hpke_nonce = hpke_export(geR,nonce_label) in
     let echo_zz = b2k(hkdf_extract(zero,e2b(geR))) in
     let ch_inner = sym_dec(echo_zz,echo) in

     let (gx_inner:element,origin:domain,=hpke_nonce) = ch_inner in

     let cert_origin = get_cert(origin) in

     event ServerSuccessReachable(ch_inner);

     let (y:bitstring,gy:element) = dh_keygen(g) in
     let gxy_inner = dh_exp(g,gx_inner,y) in
     let k_inner = b2k(hkdf_extract((CH1,SH,ch_inner),e2b(gxy_inner))) in
     let ecert = sym_enc(k_inner,cert_origin) in

     event ECHOServerDone(origin,pkR,ch_inner,hpke_nonce);
     let sh = (gy,ecert) in
     out (io,(SH, sh)))

    else (
      (* Fallback to public name and CHOuter *)
      let cert_frontend = get_cert(frontend) in

      let (y:bitstring,gy:element) = dh_keygen(g) in
      let gxy_outer = dh_exp(g,gx_outer,y) in
      let k_outer = b2k(hkdf_extract((CH1,SH,ch_outer),e2b(gxy_outer))) in

      event ServerFallbackReachable(ch_outer);

      let ecert = sym_enc(k_outer,cert_frontend) in
      event ECHOServerFallbackDone(frontend,pkR,ch_outer);
      let sh = (gy,ecert) in
      out (io,(SH, sh))))
  else (
    event ServerRetryReachable).

(********************************************************)
(* Queries *)
(********************************************************)

(* Assert that the protocol completes with sane values *)
query p:element, n:bitstring, ch_inner:bitstring, ch_outer:bitstring;
  (* Basic trace reachable events *)
  event(ClientOuterReachable);
  event(ClientInnerReachable);
  event(ServerRetryReachable);
  event(ClientOuterUnreachable);
  event(ServerFallbackReachable(ch_outer));
  event(ServerSuccessReachable(ch_inner));

  (* Basic trace unreachable events *)
  event(ClientInnerMismatchReachable);
  event(ECHOClientAcceptWithMismatch(ch_inner,n));

  (* Protocol completion reachable events *)
  event(ECHOClientDone(chosen_sni,p,ch_inner,n)) ==> event(ECHOServerDone(chosen_sni,p,ch_inner,n));
  event(ECHOClientFallbackDone(F,p,ch_outer)) ==> event(ECHOServerFallbackDone(F,p,ch_outer));

  event(ECHOClientDone(F,p,ch_inner,n));
  event(ECHOClientDone(A,p,ch_inner,n));
  event(ECHOClientDone(B,p,ch_inner,n));
  event(ECHOClientDone(chosen_sni,p,ch_inner,n));
  event(ECHOServerDone(F,p,ch_inner,n));
  event(ECHOServerDone(A,p,ch_inner,n));
  event(ECHOServerDone(B,p,ch_inner,n));
  event(ECHOServerDone(chosen_sni,p,ch_inner,n));
  event(ECHOServerFallbackDone(F,p,ch_outer));
  event(ECHOClientFallbackDone(F,p,ch_outer)).

(* Main secrecy query *)
free chosen_sni:domain [private].
noninterf chosen_sni among (A,B,F).

process
  let g = StrongDH in
  let (skF:bitstring,pkF:element) = dh_keygen(g) in
  let (skA:bitstring,pkA:element) = dh_keygen(g) in

    !ClientECHO(F,pkF,A)
  | !ClientECHO(F,pkF,B)
  | !ClientECHO(F,pkF,F)
  | !ClientECHO(F,pkF,chosen_sni)
  | !ServerECHO(F,skF,flag_false) (* server with correct key *)
  | !ServerECHO(F,skA,flag_false) (* server with incorrect key *)
