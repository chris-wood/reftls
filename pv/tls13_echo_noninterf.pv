(* TODO(caw): summarize the model details here *)
(* ../../proverif2.00/proverif tls13_echo_noninterf.pv | grep RESULT *)

(* Library Functions and Types *)
type pubkey.
type privkey.
fun pk(privkey):pubkey.
fun pke_enc(pubkey,bitstring):bitstring.
fun pke_dec(privkey,bitstring):bitstring
reduc forall sk:privkey, b:bitstring;
      pke_dec(sk,pke_enc(pk(sk),b)) = b.

type symkey.
fun sym_enc(symkey,bitstring):bitstring.
fun sym_dec(symkey,bitstring):bitstring
reduc forall k:symkey, b:bitstring;
      sym_dec(k,sym_enc(k,b)) = b.

type nonce.
fun kdf(nonce,bitstring): symkey.

type dh_pub.
type dh_priv.
fun exp(dh_priv):dh_pub.
fun dh_enc(dh_pub,nonce):bitstring.
fun dh_dec(dh_priv,bitstring):nonce
reduc forall sk:dh_priv, n:nonce;
      dh_dec(sk,dh_enc(exp(sk),n)) = n.

(* TODO(caw): consider moving to a separate library *)

(********************************************************)
(* Authenticated Encryption with Additional Data *)
(* extended with with weak/strong algorithms: See Lucky13, Beast, RC4 *)
(********************************************************)

type ae_alg.
const WeakAE, StrongAE: ae_alg.
type ae_key.
fun b2ae(bitstring):ae_key [data].

fun aead_enc(ae_alg, ae_key, bitstring, bitstring, bitstring): bitstring.
fun aead_forged(bitstring,bitstring): bitstring.

fun aead_dec(ae_alg, ae_key, bitstring, bitstring, bitstring): bitstring
reduc forall a:ae_alg, k:ae_key, n:bitstring, p:bitstring, ad:bitstring;
    aead_dec(a, k, n, ad, aead_enc(a, k, n, ad, p)) = p
otherwise forall a:ae_alg, k:ae_key, n:bitstring, p:bitstring, ad:bitstring,p':bitstring,ad':bitstring;
    aead_dec(WeakAE, k, n, ad, aead_forged(p,aead_enc(WeakAE, k, n, ad', p'))) = p.

fun aead_leak(bitstring):bitstring
reduc forall k:ae_key, n:bitstring, ad:bitstring, x:bitstring;
      aead_leak(aead_enc(WeakAE,k,n,ad,x)) = x.

(********************************************************)
(* Diffie-Hellman with small/bad subgroup attacks. See Logjam, Cross-Protocol *)
(********************************************************)

type group.
const StrongDH: group [data].
const WeakDH: group [data].

type element.
fun e2b(element): bitstring [data].
const BadElement: element [data].
const G: element [data].

fun dh_ideal(element,bitstring):element.
equation forall x:bitstring, y:bitstring;
   dh_ideal(dh_ideal(G,x),y) =
   dh_ideal(dh_ideal(G,y),x).

fun dh_exp(group,element,bitstring):element
reduc forall g:group, e:element, x:bitstring;
      dh_exp(WeakDH,e,x) = BadElement
otherwise forall g:group, e:element, x:bitstring;
      dh_exp(StrongDH,BadElement,x) = BadElement
otherwise forall g:group, e:element, x:bitstring;
      dh_exp(StrongDH,e,x) = dh_ideal(e,x).

letfun dh_keygen(g:group) =
       new x:bitstring;
       let gx = dh_exp(g,G,x) in
       (x,gx).


(*
let g = StrongDH in

- SetupSender(pkR): generate (x, gx, zz)
let (x:bitstring,gx:element) = dh_keygen(g) in
let zz_input = e2b(dh_exp(g,pkR,x)) in
let zz = hkdf_extract(zero,zz_input) in

- SetupReceiver(pkS, skR): generate (zz)
let zz_input = e2b(dh_exp(g,pkS,sk_frontend)) in
let zz = hkdf_extract(zero,zz_input) in

- Export: generate nonce (from zz)
let nonce = hkdf_expand_label(zz,echo_nonce,zero) in

- Seal(MSG): generate key/IV from zz, and encrypt
let aek = hkdf_expand_label(zz,echo_key,zero) in
let aeiv = hkdf_expand_label(zz,echo_iv,zero) in
let encrypted_ch = aead_enc(StrongAE,b2ae(aek),aeiv,MSG,zero) in

- Open(CT): generate key/IV from zz, and decrypt
let aek = hkdf_expand_label(zz,echo_key,zero) in
let aeiv = hkdf_expand_label(zz,echo_iv,zero) in
let MSG = aead_dec(StrongAE,b2ae(aek),aeiv,CT,zero) in

// End-to-end code
let g = StrongDH in
let (x:bitstring,gx:element) = dh_keygen(g) in
let gcs = e2b(dh_exp(g,gs,c)) in
let kcs = hkdf_extract(zero,gcs) in
let aek = hkdf_expand_label(kcs,tls13_esni_key,random2b(cr)) in
let aeiv = hkdf_expand_label(kcs,tls13_esni_iv,random2b(cr)) in
let enc_sni = aead_enc(StrongAE,b2ae(aek),aeiv,(e2b(gx),tkt),(sni_nonce,sni)) in
*)

type domain.
fun cert(domain): bitstring [data].

type flag.
const flag_true, flag_false: flag.

free io:channel.

(* ECHO Model *)
event ECHOClientDone(domain,pubkey,nonce).
event ECHOServerDone(domain,pubkey,nonce).
event ECHOClientFallbackDone(domain,pubkey,bitstring).
event ECHOServerFallbackDone(domain,pubkey,bitstring).
event Reachable(bitstring).
event ServerFallbackReachable(bitstring).
event ClientFallbackReachable(bitstring).

(* TODO: introduce public parameters and private parameters *)

const A: domain.
const B: domain.
const F: domain.

free chosen_sni:domain [private].
noninterf chosen_sni among (A,B,F).

(* Parametric "sni-independent" processing of sni at the server *)
letfun get_cert(sni:domain) = cert(sni).
(* Using the following instead would break noninterf of sni
   because of the comparisons:
       if sni = A then cert(A)
       else if sni = B then cert(B)
       else cert(F).
*)

letfun validate_cert(d:domain,c:bitstring) = c = cert(d).

let ClientECHOAccept(frontend:domain,pk_frontend:pubkey,origin:domain, x_inner:dh_priv, hpke_nonce:nonce, ch_inner:bitstring, sh:bitstring) =
  let (gy:bitstring,echo_used:flag,ecert:bitstring) = sh in
  let gxy = dh_dec(x_inner,gy) in
  let k_inner = kdf(gxy,(hpke_nonce,ch_inner)) in
  let cert_origin = sym_dec(k_inner,ecert) in
  if validate_cert(origin,cert_origin) then
    event ECHOClientDone(origin,pk_frontend,hpke_nonce).

let ClientECHOReject(frontend:domain,pk_frontend:pubkey,origin:domain, x_outer:dh_priv, ch_outer:bitstring, sh:bitstring) =
  let (gy:bitstring,echo_used:flag,ecert:bitstring) = sh in
  event ClientFallbackReachable(ch_outer);
  let gxy = dh_dec(x_outer,gy) in
  let k_outer = kdf(gxy,ch_outer) in
  let cert_origin = sym_dec(k_outer,ecert) in
  if validate_cert(frontend,cert_origin) then
    event ECHOClientFallbackDone(frontend,pk_frontend,ch_outer).

let ClientECHO(frontend:domain,pk_frontend:pubkey,origin:domain) =
     (* ClientHelloInner *)
     new x_inner:dh_priv;
     let gx_inner = exp(x_inner) in
     new hpke_nonce:nonce; (* hpke extract output *)

     let ch_inner = (gx_inner, origin, hpke_nonce) in

     (* ECHO *)
     let echo = pke_enc(pk_frontend,ch_inner) in

     (* ClientHelloOuter *)
     new x_outer:dh_priv;
     let gx_outer = exp(x_outer) in
     let ch_outer = (gx_outer, frontend, pk_frontend, echo) in

     (* Read a SH or HRR from the server *)
     out (io,ch_outer);
     in (io, sh:bitstring);

     let (gy:bitstring,echo_used:flag,ecert:bitstring) = sh in
     (* No retry -- process as a server hello *)
     if echo_used = flag_true then (
       (* ECHO accept *)
       ClientECHOAccept(frontend, pk_frontend, origin, x_inner, hpke_nonce, ch_inner, sh))
     else (
       (* ECHO reject *)
       ClientECHOReject(frontend, pk_frontend, origin, x_outer, ch_outer, sh)).

let ServerECHO(frontend:domain,sk_frontend:privkey) =
     in (io,ch_outer:bitstring);
     let (gx_outer:dh_pub,=frontend,pk_frontend:pubkey,echo:bitstring) = ch_outer in

     if pk_frontend = pk(sk_frontend) then (
      let ch_inner = pke_dec(sk_frontend,echo) in
      let (gx_inner:dh_pub,origin:domain,hpke_nonce:nonce) = ch_inner in

       (*
          TODO: validate nonce per the following rules.

          If decryption fails, the server MUST abort the connection with
          a "decrypt_error" alert. Moreover, if there is no "echo_nonce"
          extension, or if its value does not match the derived echo_nonce,
          the server MUST abort the connection with a "decrypt_error" alert.
          Next, the server MUST scan ClientHelloInner for any "outer_extension"
          extensions and substitute their values with the values in ClientHelloOuter.
          It MUST first verify that the hash found in the extension matches the hash
          of the extension to be interpolated in and if it does not, abort the connections
          with a "decrypt_error" alert.
       *)

       let cert_origin = get_cert(origin) in
       new gxy:nonce;
       let gy = dh_enc(gx_inner,gxy) in

       let k = kdf(gxy,(hpke_nonce,ch_inner)) in

       let sh = gy in
       let ecert = sym_enc(k,cert_origin) in
       event ECHOServerDone(origin,pk(sk_frontend),hpke_nonce);
       out (io,(gy,flag_true,ecert)))

      else (

        (* Fallback to public name and CHOuter *)
        let cert_origin = get_cert(frontend) in
        new gxy:nonce;
        let gy = dh_enc(gx_outer,gxy) in

        let k = kdf(gxy,ch_outer) in

        event ServerFallbackReachable(ch_outer);

        let sh = gy in
        let ecert = sym_enc(k,cert_origin) in
        event ECHOServerFallbackDone(frontend,pk(sk_frontend),ch_outer);
        out (io,(gy,flag_false,ecert))).


query h:domain, p:pubkey, n:nonce, ch:bitstring;
      event(ServerFallbackReachable(ch));
      event(ClientFallbackReachable(ch));
      event(ECHOClientDone(F,p,n));
      event(ECHOClientDone(A,p,n));
      event(ECHOClientDone(B,p,n));
      event(ECHOClientDone(chosen_sni,p,n));
      event(ECHOServerDone(F,p,n));
      event(ECHOServerDone(A,p,n));
      event(ECHOServerDone(B,p,n));
      event(ECHOServerDone(chosen_sni,p,n));
      event(ECHOServerFallbackDone(F,p,ch));
      event(ECHOClientFallbackDone(F,p,ch)).

process
  new skF:privkey;
  new skA:privkey;
  let pkF = pk(skF) in
  let pkA = pk(skA) in
    !ClientECHO(F,pkF,A)
  | !ClientECHO(F,pkF,B)
  | !ClientECHO(F,pkF,F)
  | !ClientECHO(F,pkF,chosen_sni)
  | !ServerECHO(F,skF)
  | !ServerECHO(F,skA) (* server with an old key *)
